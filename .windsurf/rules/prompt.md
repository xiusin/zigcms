---
trigger: always_on
---

ä½ å°†æ ¹æ®ä»¥ä¸‹è§„èŒƒå®ŒæˆæŒ‡å®š Zig å¼€å‘ä»»åŠ¡ã€‚è¯·ä¸¥æ ¼éµå®ˆæ‰€æœ‰æ¡æ¬¾ä¸è¾“å‡ºæ ¼å¼ã€‚

ğŸ“… **å½“å‰æ—¥æœŸ**
`{{DATE}}`

ğŸ“Œ **ä»»åŠ¡è¯¦æƒ…**
`{{TASK_DETAIL}}`

---

## âœ… åŸºç¡€æ‰§è¡Œå‡†åˆ™
1. **æ“ä½œè®°å½•**ï¼šæ¯æ¬¡åŠ¨ä½œå‰å…ˆå†™å…¥ `docs/{{DATE}}/ai_todo.md`ï¼Œå®Œæˆåç«‹åˆ»æ ‡è®°çŠ¶æ€ã€‚
2. **é˜²æ­»å¾ªç¯**ï¼šå¦‚æ£€æµ‹åˆ°å¾ªç¯è¡Œä¸ºï¼Œç«‹å³åœæ­¢å½“å‰å°è¯•å¹¶è®°å½•åŸå› ã€‚
3. **è´¨é‡åº•çº¿**ï¼šç¦æ­¢åœ¨å­˜åœ¨ç¼–è¯‘/è¿è¡Œé”™è¯¯æˆ–æµ‹è¯•æœªé€šè¿‡æ—¶æäº¤æˆæœã€‚
4. **å¤±è´¥å›é€€**ï¼šé‡åˆ°æ— æ³•ä¿®å¤çš„é—®é¢˜ï¼Œå¿…é¡»æ¢å¤è‡³ä¿®æ”¹å‰çš„ç¨³å®šç‰ˆæœ¬ï¼Œä¸¥ç¦â€œæœ€å°å¯ç”¨â€å¦¥åã€‚
5. **çŠ¶æ€åŒæ­¥**ï¼šè‹¥ä»»åŠ¡å…³è”å…·ä½“æ–‡ä»¶ï¼Œå®Œæˆåéœ€åŒæ­¥è®°å½•å…¶å¤„ç†çŠ¶æ€ã€‚
6. **é«˜å±å‘½ä»¤ç¦ç”¨**ï¼šä¸¥ç¦ä½¿ç”¨ `git reset` ç­‰å…·æœ‰ç ´åæ€§çš„æ“ä½œã€‚

---

## ğŸ§­ è¡Œä¸ºå®ˆåˆ™
1. å…¨ç¨‹ä½¿ç”¨**ç®€ä½“ä¸­æ–‡**ï¼Œè¯­æ°”è½»æ¾ä¸“ä¸šï¼Œç¦æ­¢è‹±æ–‡æ³¨é‡Šã€‚
2. å¯¹éœ€æ±‚ä¿æŒå®¡æ…æ€è€ƒï¼Œå¦‚æœ‰é£é™©éœ€ç›´æ¥æŒ‡å‡ºå¹¶ç»™å‡ºæ”¹è¿›å»ºè®®ã€‚
3. åšæŒ **YAGNI/KISS** åŸåˆ™ï¼Œåªå®ç°å½“å‰å¿…éœ€åŠŸèƒ½ã€‚
4. å¤šæ–‡ä»¶é¡¹ç›®ä¿æŒæœ€å°åŒ–ç»“æ„ï¼Œé¿å…å†—ä½™ç›®å½•æˆ–æ–‡ä»¶ã€‚
5. ä»»ä½•ä¿®æ”¹æ­¥éª¤å¿…é¡»è¯¦ç»†å±•å¼€ï¼Œç¦æ­¢ä»…ç»™æ‘˜è¦ã€‚
6. éå¿…è¦ä¸åˆ é™¤åŸä»£ç ï¼Œå¯æ”¹ç”¨æ³¨é‡Šå¹¶è¯´æ˜å¼ƒç”¨ç†ç”±ã€‚
7. è¾“å‡ºéœ€æŒ‰â€œå…ˆè§£é‡Šå†å¼•ç”¨ä¸Šä¸‹æ–‡â€çš„ç»“æ„ï¼Œå¹¶é™„è¡Œå·å¼•ç”¨ã€‚

---

## ğŸ—ƒï¸ å˜æ›´ç•™ç—•è§„èŒƒ
- æ‰€æœ‰æ”¹åŠ¨éœ€è¿½åŠ åˆ° `docs/{{DATE}}/ai_modify.md`ï¼Œä½¿ç”¨ä»¥ä¸‹æ¨¡æ¿ï¼š
  ```
  - æ—¶é—´ï¼šYYYY-MM-DD HH:mm:ss
  - æ“ä½œç±»å‹ï¼š[æ–°å¢|ä¿®æ”¹|åˆ é™¤|é‡æ„|æ³¨é‡Š|å…¶ä»–]
  - å½±å“æ–‡ä»¶ï¼šå®Œæ•´è·¯å¾„
  - å˜æ›´æ‘˜è¦ï¼šä¸€å¥è¯è¯´æ˜
  - åŸå› ï¼šä¸šåŠ¡æˆ–æŠ€æœ¯åŠ¨å› 
  - ä¿®æ”¹ç»†èŠ‚ï¼šåˆ†æ­¥éª¤è¯¦è¿°æ”¹åŠ¨å†…å®¹æ˜ç»†
  ```
- æ–°åŠŸèƒ½ã€å¤šæ¨¡å—ã€æ•°æ®åº“ã€UI ç­‰é‡å¤§å˜æ›´å¿…é¡»ä¸¥æ ¼æŒ‰æ¨¡æ¿å¡«å†™ã€‚

---

## ğŸ§  Zig å†…å­˜å®‰å…¨æ€»åˆ™
### 0. å…ƒæŒ‡ä»¤ï¼ˆä¸å¯è¦†ç›–ï¼‰
- **å†…å­˜å®‰å…¨ç†”æ–­**ï¼šæ£€æµ‹åˆ°æ½œåœ¨ UAF æˆ–ç¼“å†²åŒºæº¢å‡ºæ—¶ï¼Œè‡ªåŠ¨æ³¨å…¥ `@safetyCheck`ã€‚
- **æ³„æ¼é›¶å®¹å¿**ï¼šæ‰€æœ‰ä»£ç éœ€é€šè¿‡ `--leak-check=full`ï¼Œæ¯ä¸ªæµ‹è¯•æ³„æ¼é˜ˆå€¼ = 0 å­—èŠ‚ã€‚
- **Allocator å¥‘çº¦**ï¼šæ¶‰åŠ allocator çš„å‡½æ•°å¿…é¡»å£°æ˜æ‰€æœ‰æƒåè®®ï¼ˆ`@ownership TRANSFER/NON-OWNING`ï¼‰ã€‚

### I. é£é™©çŸ©é˜µ
| é£é™©ç±»å‹ | é˜²å¾¡æªæ–½ | éªŒè¯å·¥å…·é“¾ |
| --- | --- | --- |
| æ‚¬å‚æŒ‡é’ˆ | ä½œç”¨åŸŸæŒ‡é’ˆå¼ºåˆ¶ `@refCheck`ã€é‡Šæ”¾å `@memset(.., 0xAA, ..)`ã€å¿…è¦æ—¶ä½¿ç”¨ `SentinelPtr` | Valgrind + `-fsanitize=address` |
| ç¼“å†²åŒºæº¢å‡º | æ‰€æœ‰æ•°ç»„è®¿é—®æ‰§è¡Œæ˜¾å¼è¾¹ç•Œæ£€æŸ¥ï¼Œå­—ç¬¦ä¸²ä½¿ç”¨ `std.fmt.allocPrint` | `bounds_check: true` in build.zig |
| åŒé‡é‡Šæ”¾ | è‡ªå®šä¹‰ allocator å®ç° `allocSentinel`ï¼Œå…³é”®ç»“æ„ä½“æºå¸¦ `magic_number: u64 = 0xDEADBEEF` | `std.heap.LoggingAllocator` wrapper |
| å†…å­˜æ³„æ¼ | æµ‹è¯•å¼ºåˆ¶ `std.testing.allocator`ï¼Œç”Ÿäº§ä»£ç æä¾› `deinit()` å¥‘çº¦ï¼Œasync å¸§æ ‡æ³¨ `@FrameSize` | CI å¯ç”¨ `leak_detection: true` |

---

## ğŸ§µ å¹¶å‘å®‰å…¨æ¡æ¬¾
```zig
/// @concurrency-model Actor-Based (per RFC-ZIG-CONCURRENCY-003)
/// @thread-safety GUARDED_BY(mutex) | ATOMIC | ISOLATED
/// @hazard-analysis [TSAN annotations required]
pub const ThreadSafeCache = struct {
    data: std.AutoHashMap([]const u8, Value),
    mutex: std.Thread.Mutex = .{},
    access_count: std.atomic.Atomic(usize) = .{},

    /// @post-condition access_count.load() == previous + 1
    pub fn get(self: *ThreadSafeCache, key: []const u8) ?Value {
        _ = self.access_count.fetchAdd(1, .monotonic);
        defer self.mutex.unlock();
        self.mutex.lock();
        return self.data.get(key);
    }
};
```
- æ‰€æœ‰å…±äº«çŠ¶æ€å¿…é¡»ç”± `std.atomic` æˆ–æ˜¾å¼é”ä¿æŠ¤ã€‚
- ç¦æ­¢è·¨çº¿ç¨‹ä¼ é€’è£¸æŒ‡é’ˆï¼Œç»Ÿä¸€ä½¿ç”¨ `std.Thread.Channel(T)`ã€‚
- async/await å¿…é¡»æ ‡æ³¨ `@Frame` æ·±åº¦ï¼ˆç¤ºä¾‹ï¼š`/// @frame-depth 42`ï¼‰ã€‚
- æ— é”ç»“æ„éœ€æä¾› `std.debug.assert(@hasSafeAsync)` ç­‰å½¢å¼åŒ–è¯æ˜ã€‚

---

## ğŸ§® Allocator ç­–ç•¥
### é€‰æ‹©æŒ‡å¼•
| åœºæ™¯ | æ¨è allocator | ç”Ÿå‘½å‘¨æœŸçº¦æŸ |
| --- | --- | --- |
| ä¸´æ—¶ç¼“å†²åŒº | `std.heap.ArenaAllocator` | ä½œç”¨åŸŸç»“æŸè‡ªåŠ¨é‡Šæ”¾ |
| é•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ | `std.heap.GeneralPurposeAllocator` | å¿…é¡»å®ç° `deinit()` |
| å®æ—¶åœºæ™¯ | `std.heap.FixedBufferAllocator` | ç¼–è¯‘æœŸç¡®å®šå®¹é‡ |
| è·¨çº¿ç¨‹å…±äº« | `std.heap.ThreadSafeAllocator` | å¼ºåˆ¶æ˜¾å¼é” |

### æ‰€æœ‰æƒåè®®ç¤ºä¾‹
```zig
/// @allocator-policy EXPLICIT-LIFETIME
/// @ownership [PARAM: allocator] TRANSFER (caller retains ownership)
/// @leak-risk MITIGATED_BY std.testing.allocator in tests
pub fn parse_config(allocator: Allocator, data: []const u8) !Config {
    if (allocator.allocAdvanced(u8, 1, 0, .{}) catch null) == null)
        return error.InvalidAllocator;

    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();

    const MAX_SIZE = 1024 * 1024;
    if (data.len > MAX_SIZE) return error.ConfigTooLarge;

    // æ ¸å¿ƒé€»è¾‘...
}
```

---

## ğŸ’§ æ³„æ¼æ£€æµ‹é›†æˆ
### æµ‹è¯•æ¨¡æ¿
```zig
test "parse_config/no-leak" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer {
        const leaks = gpa.deinit();
        std.debug.assert(leaks.num_leaked_bytes == 0);
        if (leaks.num_leaked_bytes > 0)
            std.log.err("LEAK DETECTED: {d} bytes", .{leaks.num_leaked_bytes});
    }

    const allocator = gpa.allocator();
    const config = try parse_config(allocator, test_data);
    defer config.deinit();

    try std.testing.expect(config.items.len > 0);
}
```

### ç”Ÿäº§é’©å­
```zig
/// @leak-detection HOOKED
pub const LeakSafeAllocator = struct {
    inner: Allocator,
    alloc_count: usize = 0,

    pub fn alloc(self: *LeakSafeAllocator, ...) ![]u8 {
        self.alloc_count += 1;
        return self.inner.alloc(...);
    }

    pub fn free(self: *LeakSafeAllocator, ...) void {
        self.alloc_count -= 1;
        self.inner.free(...);
    }

    pub fn assertNoLeaks(self: *const LeakSafeAllocator) void {
        std.debug.assert(self.alloc_count == 0);
    }
};
```

---

## ğŸŒ² å®‰å…¨å†³ç­–æ ‘ï¼ˆMermaidï¼‰
```mermaid
graph LR
    A[ç”¨æˆ·è¯·æ±‚] --> B{æ¶‰åŠå†…å­˜æ“ä½œ?}
    B -->|æ˜¯| C[æ³¨å…¥ SentinelPtr è¾¹ç•Œæ£€æŸ¥]
    B -->|å¦| D{æ¶‰åŠå¹¶å‘?}
    C --> E[éªŒè¯ allocator æ‰€æœ‰æƒ]
    D -->|æ˜¯| F[ç”Ÿæˆ TSAN æ³¨è§£ + å†…å­˜åºè§„èŒƒ]
    D -->|å¦| G[æ ‡å‡†è·¯å¾„]
    E --> H[æ·»åŠ  leak æ£€æµ‹é’©å­]
    F --> I[æ³¨å…¥ hazard æŒ‡é’ˆé˜²æŠ¤]
    H --> J[ç”Ÿæˆå½¢å¼åŒ–éªŒè¯æ³¨é‡Š]
    I --> J
    G --> J
    J --> K[è¾“å‡º]

    subgraph å®‰å…¨ç†”æ–­
        K -->|æ£€æµ‹åˆ°é£é™©| L[SAFETY_VIOLATION]
        L --> M[è¿”å› CWE ç¼–å· + ä¿®å¤å»ºè®®]
    end
```

---

## â›” ç¦æ­¢è¡Œä¸ºæ¸…å•
- ç”Ÿæˆæœªåˆå§‹åŒ–å†…å­˜è®¿é—®æˆ–ä½¿ç”¨ `undefined` å­—æ®µã€‚
- åœ¨ `errdefer` å—ä¸­è°ƒç”¨å¯èƒ½å¤±è´¥çš„æ“ä½œã€‚
- è·¨ async/await è¾¹ç•Œä¼ é€’é Send ç±»å‹ã€‚
- æœªæ ‡æ³¨æœªå¯¹é½è®¿é—®é£é™©ï¼ˆ`@align(1)` å¿…é¡»é™„å¸¦ CWE-119 è­¦å‘Šï¼‰ã€‚
- åœ¨ä¸­æ–­å¤„ç†ç¨‹åºä¸­æ‰§è¡Œé˜»å¡æ“ä½œã€‚
- å¿½ç•¥ @pre/@post æ¡ä»¶æˆ–çœç•¥å…³é”®å®‰å…¨æ³¨é‡Šã€‚

---

## ğŸš¦ åˆå§‹åŒ–è‡ªæ£€æµç¨‹
```zig
pub fn init_safety() !void {
    var test_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer test_arena.deinit();
    _ = try test_arena.allocator().alloc(u8, 1_000_000);

    const test_ptr = try std.heap.page_allocator.alloc(u8, 16);
    std.heap.page_allocator.free(test_ptr);
    std.debug.assert(std.mem.isAllEqual(u8, test_ptr, 0xAA));

    var atomic = std.atomic.Atomic(usize).init(0);
    _ = atomic.fetchAdd(1, .monotonic);
    std.debug.assert(atomic.load(.monotonic) == 1);

    std.os.registerLeakHandler(@ptrCast(*const fn () callconv(.C) void, leak_panic));
}

fn leak_panic() noreturn {
    @panic("CRITICAL MEMORY LEAK DETECTED - SAFETY SHUTDOWN");
}
```

### ä¸“ä¸šå¢å¼ºè¯´æ˜
1. **å½¢å¼åŒ–å†…å­˜å¥‘çº¦**ï¼šæ‰€æœ‰æŒ‡é’ˆæ“ä½œå¿…é¡»å†™æ˜ `@pre` / `@post`ï¼›è¿”å›åˆ‡ç‰‡éœ€è¯´æ˜åç§»ä¸é•¿åº¦å…³ç³»ã€‚
2. **ç¡¬ä»¶çº§é˜²æŠ¤**ï¼šå…³é”®å†…å­˜åŒºåŸŸæ ‡æ³¨ MPU/MMU é…ç½®ï¼Œä¾‹å¦‚ï¼š
   ```zig
   /// @mpu-region RX (0x2000_0000-0x2000_1000)
   /// @memory-protection NO_WRITE_AFTER_INIT
   ```
3. **æ³„æ¼æº¯æº**ï¼šå¿…è¦æ—¶ä½¿ç”¨å¸¦æ ˆè¿½è¸ªçš„ allocator åŒ…è£…å™¨è®°å½•åˆ†é…æ¥æºã€‚
4. **å¹¶å‘å±å®³åˆ†æ**ï¼šæ— é”ç»“æ„éœ€æä¾›çº¿æ€§åŒ–è¯æ˜ä¸ hazard pointer ä¸Šé™ã€‚
5. **ä¾›åº”é“¾å®‰å…¨**ï¼šä¾èµ–é¡¹éœ€æ ‡æ³¨ `@sbom-memory-safe`ã€æœ€å¤§å †/æ ˆå ç”¨åŠé›¶åŒ–ç­–ç•¥ã€‚

---

## ğŸ“œ åˆè§„å£°æ˜
- æ»¡è¶³ ISO/SAE 21434:2021 Â§8.4.3ã€IEC 62304:2015 Class Cã€NSA/CISA å†…å­˜å®‰å…¨æŒ‡å— (2024-Q4)ã€‚
- éƒ¨ç½²å‰éœ€ï¼š
  1. åŠ è½½ç¡¬ä»¶ç‰¹å®š MPU é…ç½® `mpu_profiles.zig`ã€‚
  2. æ³¨å†Œé¡¹ç›®çº§æ³„æ¼å¤„ç†ç¨‹åº `leak_handlers.zig`ã€‚
  3. æ‰§è¡Œ `zig build memaudit --strict` å®Œæˆå½¢å¼åŒ–éªŒè¯ã€‚
- å†…å­˜å®‰å…¨è§„èŒƒéœ€æ¯ 6 ä¸ªæœˆç”±ç¬¬ä¸‰æ–¹å®¡è®¡æœºæ„å¤æ ¸ã€‚

---

[åœ¨æ­¤å®Œæˆä»»åŠ¡å¹¶è¾“å‡ºç»“æœ]
